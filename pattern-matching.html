<!DOCTYPE html><html lang="en"><head><title>Pattern matching | Novah language</title><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="/css/main.css"><link rel="icon" href="/img/novah.png"><script src="/js/main.js"></script><script src="/js/microlight.js"></script></head><body><a href="#main" class="visually-hidden">Skip to main content</a><header><div class="header-content"><a href="/" aria-label="Novah homepage" class="header-title"><img src="/img/novah.svg" width="32" height="32" alt="logo" class="logo">Novah</a><a href="//github.com/stackoverflow/novah" class="source"><img src="/img/GitHub-Mark-Light-32px.png" width="16" height="16" alt="Github">Source</a></div><button onclick="onNavToggle()" aria-haspopup="menu" aria-controls="nav" aria-expanded="false" class="nav-mobile closed"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" viewBox="0 0 16 16" class="nav-icon"><path fill-rule="evenodd" d="M2.5 11.5A.5.5 0 0 1 3 11h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4A.5.5 0 0 1 3 7h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4A.5.5 0 0 1 3 3h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5z"></path></svg></button></header><div id="content"><nav id="nav"><ul class="nav-list"><li aria-current="false" role="menuitem" tabIndex="-1"><a href="/">Home</a></li><li aria-current="false" role="menuitem" tabIndex="null"><a href="/syntax">Syntax</a></li><li aria-current="false" role="menuitem" tabIndex="null"><a href="/types">Types</a></li><li aria-current="false" role="menuitem" tabIndex="null"><a href="/records">Records</a></li><li aria-current="page" role="menuitem" tabIndex="null" class="nav-selected"><a href="/pattern-matching">Pattern matching</a></li><li aria-current="false" role="menuitem" tabIndex="null"><a href="/interop">Java interoperability</a></li><li aria-current="false" role="menuitem" tabIndex="null"><a href="/computations">Computation expressions</a></li><li aria-current="false" role="menuitem" tabIndex="null"><a href="/instance">Instance arguments</a></li><li aria-current="false" role="menuitem" tabIndex="null"><a href="/apidoc">API docs</a></li></ul></nav><main id="main"><h1 id="patterns" tabIndex="-1">Pattern Matching</h1><p>Novah supports pattern matching using the <code class="inline-code">case ... of</code> syntax.
It also supports pattern destructuring for functions and let declarations.
</p><table aria-labelledby="patterns"><thead><tr><th scope="col">Pattern</th><th scope="col">Example</th><th scope="col">Description</th></tr></thead><tbody><tr><td>Wildcard</td><td><code>_</code></td><td>Always matches</td></tr><tr><td>Variable</td><td><code>a, foo</code></td><td>Always matches and binds the value to the variable</td></tr><tr><td>Literal</td><td><code>1, 4.5, "foo", 'a', true</code></td><td>Matches the exact literal</td></tr><tr><td>Unit</td><td><code>()</code></td><td>Matches the value to unit</td></tr><tr><td>Constructor</td><td><code>Nil, Some x, None</code></td><td>Matches the specified constructor of a type</td></tr><tr><td>List</td><td><code>[], [x, _], [head :: tail], [x, y, z :: rest]</code></td><td>Matches a list that can be empty, contain some elements and a tail</td></tr><tr><td>Regex</td><td><code>#"\d", #"\w+"</code></td><td>Matches the whole regex against the input</td></tr><tr><td>Record</td><td><code>{x, y}, {name}</code></td><td>Matches the specified fields of a record</td></tr><tr><td>Named pattern</td><td><code>[x :: _] as list, {name} as person</code></td><td>Binds the whole pattern to the given name</td></tr><tr><td>Type test</td><td><code>:? String, :? File as file</code></td><td>Matches the value to the specified runtime type</td></tr></tbody></table><h2>Pattern guards</h2><p>Patterns can have guards for additional filtering.</p><p class="visually-hidden">Begin code:</p><pre class="code"><code class="microlight">module guards

foo : Int -> Int
foo x = case x of
  0 -> 0
  n if n &lt; 0 -> n * -1
  n -> n</code></pre><p class="visually-hidden">End code.</p><h2>Multiple patterns</h2><p>Case expressions can match on multiple patterns at the same time.</p><p class="visually-hidden">Begin code:</p><pre class="code"><code class="microlight">module multipatterns

foo : Option Int -> Option Int -> Option Int
foo x y = case x, y of
  Some v1, Some v2 -> Some (v1 + v2)
  _, _ -> None</code></pre><p class="visually-hidden">End code.</p><h2>Destructuring</h2><p>Function parameters and let declarations can be destructured directly.
Incomplete patterns require a <code class="inline-code">noWarn</code> attribute to compile.
</p><p class="visually-hidden">Begin code:</p><pre class="code"><code class="microlight">module destructuring

foo : { x : Int, y : Int } -> Unit
foo {x, y} = printfln "Point %d %d" [x, y]

#[noWarn]
bar () =
  let [match, group1, group2] = Re.find #"(\d), (\d)" "3, 9"
  let sum = int group1 + int group2
  printfln "the sum of %s is %s" [match, show sum]</code></pre><p class="visually-hidden">End code.</p></main></div></body></html>