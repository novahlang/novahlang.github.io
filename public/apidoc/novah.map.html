<!DOCTYPE html>
<html>
<head>
    <title>Novah apidocs</title>
    <meta charset="UTF-8">
    <style>
        a {
            color: #111;
            text-decoration: none;
            padding-bottom: 2px;
            border-bottom: 1px solid #aaa;
        }

        hr {
            margin-top: 40px;
        }

        h2 {
            padding-top: 40px;
        }

        .content {
            display: flex;
        }

        .menu {
            min-width: 15%;
            padding-right: 10px;
            border-right: 1px solid #aaa;
        }

        .docs {
            padding-left: 5%;
        }
    </style>
</head>
<body>
    <h1>Novah Documentation</h1>
    <div class="content">
        <div class="menu"><h3>Modules</h3><p><a href="novah.core.html">novah.core</a></p><p><a href="novah.result.html">novah.result</a></p><p><a href="novah.number.html">novah.number</a></p><p><a href="novah.random.html">novah.random</a></p><p><a href="novah.java.html">novah.java</a></p><p><a href="novah.math.html">novah.math</a></p><p><a href="novah.meta.html">novah.meta</a></p><p><a href="novah.linkedList.html">novah.linkedList</a></p><p><a href="novah.option.html">novah.option</a></p><p><a href="novah.stream.html">novah.stream</a></p><p><a href="novah.list.html">novah.list</a></p><p><a href="novah.map.html">novah.map</a></p><p><a href="novah.set.html">novah.set</a></p><p><a href="novah.regex.html">novah.regex</a></p><p><a href="novah.string.html">novah.string</a></p><p><a href="novah.io.html">novah.io</a></p><p><a href="novah.test.html">novah.test</a></p><p><a href="novah.async.html">novah.async</a></p><p><a href="novah.computation.html">novah.computation</a></p><p><a href="novah.array.html">novah.array</a></p></div>
        <div class="docs"><h2>novah.map</h2><p>Functions to work with persistent maps.</p>
<h2>Types</h2><h2>Declarations</h2><hr><h4>new</h4><pre>visibility: public</pre><pre>type: List (Tuple k v) -> Map k v</pre><div><p>Creates a new map with the supplied entries.</p>
</div><hr><h4>newEq</h4><pre>visibility: public</pre><pre>type: {{ Equals k }} -> Option (k -> Int64) -> Map k v</pre><div><p>Creates a new map which uses the key equality function and the provided hash function, or the default object hash function.
This function should always be used to create new maps for types that have equality implementations that differ from its own
<code>equals</code> function.
Note that Novah creates default, sensible <code>equals</code> and <code>hashCode</code> implementations for every type.</p>
</div><hr><h4>size</h4><pre>visibility: public</pre><pre>type: Map k v -> Int64</pre><div><p>Returns the size of the map.
Runtime: O(1)</p>
</div><hr><h4>isEmpty</h4><pre>visibility: public</pre><pre>type: Map k v -> Boolean</pre><div><p>Return true if the map is empty
Runtime: O(1)</p>
</div><hr><h4>isNotEmpty</h4><pre>visibility: public</pre><pre>type: Map k v -> Boolean</pre><div><p>Return true if the map is not empty
Runtime: O(1)</p>
</div><hr><h4>put</h4><pre>visibility: public</pre><pre>type: k -> v -> Map k v -> Map k v</pre><div><p>Inserts or replaces a new key/value pair in the map.
Runtime: ~O(1)</p>
</div><hr><h4>get</h4><pre>visibility: public</pre><pre>type: k -> Map k v -> Option v</pre><div><p>Returns the value under key if it exists.
Runtime: ~O(1)</p>
</div><hr><h4>getOr</h4><pre>visibility: public</pre><pre>type: k -> v -> Map k v -> v</pre><div><p>Returns the value under key if it exists, or the default value.
Runtime: ~O(1)</p>
</div><hr><h4>update</h4><pre>visibility: public</pre><pre>type: k -> (v -> v) -> Map k v -> Map k v</pre><div><p>Applies the function to the value represented by the key, updating it.
Does nothing if the key is not present.
Runtime: ~O(1)</p>
</div><hr><h4>updateOr</h4><pre>visibility: public</pre><pre>type: k -> (v -> v) -> v -> Map k v -> Map k v</pre><div><p>Applies the function to the value represented by the key, updating it.
Inserts the or value if the key is not present.
Runtime: ~O(1)</p>
</div><hr><h4>remove</h4><pre>visibility: public</pre><pre>type: k -> Map k v -> Map k v</pre><div><p>Removes the key from this map.
Runtime: ~O(1)</p>
</div><hr><h4>hasKey</h4><pre>visibility: public</pre><pre>type: k -> Map k v -> Boolean</pre><div><p>Returns true if this map contains the key.
Runtime: ~O(1)</p>
</div><hr><h4>merge</h4><pre>visibility: public</pre><pre>type: Map k v -> Map k v -> Map k v</pre><div><p>Returns the result of merging the two maps.
Repeated keys in the second map will overwrite keys from the first.
An alias for <code>++</code>.</p>
</div><hr><h4>keys</h4><pre>visibility: public</pre><pre>type: Map k v -> Set k</pre><div><p>Returns a set of all keys in this map.
Runtime: O(1)</p>
</div><hr><h4>values</h4><pre>visibility: public</pre><pre>type: Map k v -> List v</pre><div><p>Returns a list of all values in this map.
Runtime: O(n)</p>
</div><hr><h4>entries</h4><pre>visibility: public</pre><pre>type: Map k v -> List (Tuple k v)</pre><div><p>Returns a list of all keys and values in this map</p>
</div><hr><h4>forEach</h4><pre>visibility: public</pre><pre>type: Map k v -> (k -> v -> Unit) -> Unit</pre><div><p>Executes the function for every key/value pair in this map
Runtime: O(n)</p>
</div><hr><h4>mapValues</h4><pre>visibility: public</pre><pre>type: (k -> v -> v2) -> Map k v -> Map k v2</pre><div><p>Maps function f over all entries of this map.
Runtime: O(n)</p>
</div><hr><h4>filter</h4><pre>visibility: public</pre><pre>type: (k -> v -> Boolean) -> Map k v -> Map k v</pre><div><p>Returns a map of the elements that match the given predicate.
Runtime: O(n)</p>
</div><hr><h4>foldl</h4><pre>visibility: public</pre><pre>type: (b -> k -> v -> b) -> b -> Map k v -> b</pre><div><p>Folds this map into a single value according to the folding function.
Runtime: O(n)</p>
</div><hr><h4>all</h4><pre>visibility: public</pre><pre>type: (k -> v -> Boolean) -> Map k v -> Boolean</pre><div><p>Returns true if the predicate is true for every entry in this map.
Runtime: O(n)</p>
</div><hr><h4>any</h4><pre>visibility: public</pre><pre>type: (k -> v -> Boolean) -> Map k v -> Boolean</pre><div><p>Returns true if the predicate is true for any entry in this map.
Runtime: O(n)</p>
</div><hr><h4>concatMap</h4><pre>visibility: public</pre><pre>type: Concat (Map k v)</pre><hr><h4>toList</h4><pre>visibility: public</pre><pre>type: Map k v -> List (Tuple k v)</pre><div><p>Returns a list containing every key/value pair from this map.
Runtime: O(n)</p>
</div><hr><h4>eqMap</h4><pre>visibility: public</pre><pre>type: {{ Equals k }} -> {{ Equals v }} -> Equals (Map k v)</pre><hr><h4>withLinear</h4><pre>visibility: public</pre><pre>type: Map k v -> (Map k v -> b) -> Map k v</pre><div><p>Creates a linear (mutable) version of the given map and applies the function to it.
Returns a forked (persistent) version of the returned linear map.
This function should be used when lots of expensive mutating operations have to be run on a map
and can be seen as a builder for the resulting map.
All functions that alter maps like <code>put</code>, <code>update</code>, <code>remove</code>, etc.
will mutate a linear map.
Ex:
withLinear (Map.new [&quot;a&quot; ; 1, &quot;b&quot; ; 2, &quot;c&quot; ; 3]) \map -&gt;
put &quot;d&quot; 4 map
remove &quot;b&quot; map</p>
<p>-&gt; {&quot;a&quot; 1, &quot;c&quot; 3, &quot;d&quot; 4}</p>
</div><hr><h4>associate</h4><pre>visibility: public</pre><pre>type: (a -> Tuple k v) -> List a -> Map k v</pre><div><p>Creates a map out of a list based on the given function.
Runtime: O(n)</p>
</div><hr><h4>showMapp</h4><pre>visibility: private</pre><pre>type: Show k -> Show v -> Map k v -> String</pre><hr><h4>showMap</h4><pre>visibility: public</pre><pre>type: {{ Show k }} -> {{ Show v }} -> Show (Map k v)</pre>
    </div>
</body>
</html>