<!DOCTYPE html>
<html>
<head>
    <title>Novah apidocs</title>
    <meta charset="UTF-8">
    <style>
        a {
            color: #111;
            text-decoration: none;
            padding-bottom: 2px;
            border-bottom: 1px solid #aaa;
        }

        hr {
            margin-top: 40px;
        }

        h2 {
            padding-top: 40px;
        }

        .content {
            display: flex;
        }

        .menu {
            min-width: 15%;
            padding-right: 10px;
            border-right: 1px solid #aaa;
        }

        .docs {
            padding-left: 5%;
        }
    </style>
</head>
<body>
    <h1>Novah Documentation</h1>
    <div class="content">
        <div class="menu"><h3>Modules</h3><p><a href="novah.core.html">novah.core</a></p><p><a href="novah.result.html">novah.result</a></p><p><a href="novah.number.html">novah.number</a></p><p><a href="novah.random.html">novah.random</a></p><p><a href="novah.java.html">novah.java</a></p><p><a href="novah.math.html">novah.math</a></p><p><a href="novah.meta.html">novah.meta</a></p><p><a href="novah.linkedList.html">novah.linkedList</a></p><p><a href="novah.option.html">novah.option</a></p><p><a href="novah.stream.html">novah.stream</a></p><p><a href="novah.list.html">novah.list</a></p><p><a href="novah.map.html">novah.map</a></p><p><a href="novah.set.html">novah.set</a></p><p><a href="novah.regex.html">novah.regex</a></p><p><a href="novah.string.html">novah.string</a></p><p><a href="novah.io.html">novah.io</a></p><p><a href="novah.test.html">novah.test</a></p><p><a href="novah.async.html">novah.async</a></p><p><a href="novah.computation.html">novah.computation</a></p><p><a href="novah.array.html">novah.array</a></p></div>
        <div class="docs"><h2>novah.set</h2><p>Functions to work with persistent sets.
Literal sets can be created using <code>#{}</code>.</p>
<h2>Types</h2><h2>Declarations</h2><hr><h4>new</h4><pre>visibility: public</pre><pre>type: {{ Equals a }} -> Option (a -> Int64) -> Set a</pre><div><p>Creates a new set which uses the element equality function and the provided hash function, or the default object hash function.
This function should always be used to create new sets for types that have equality implementations that differ from its own
<code>equals</code> function.
Note that Novah creates default, sensible <code>equals</code> and <code>hashCode</code> implementations for every type, so this function is only needed
for types where the <code>equals</code> function and the <code>Equals</code> type class implementation diverge.</p>
</div><hr><h4>add</h4><pre>visibility: public</pre><pre>type: a -> Set a -> Set a</pre><div><p>Inserts this element in the set.
Runtime: ~O(1)</p>
</div><hr><h4>remove</h4><pre>visibility: public</pre><pre>type: a -> Set a -> Set a</pre><div><p>Removes this element from the set.
Runtime: ~O(1)</p>
</div><hr><h4>size</h4><pre>visibility: public</pre><pre>type: Set a -> Int32</pre><div><p>Returns the size of this set.
Runtime: O(1)</p>
</div><hr><h4>isEmpty</h4><pre>visibility: public</pre><pre>type: Set a -> Boolean</pre><div><p>Returns true if this set is empty.
Runtime: O(1)</p>
</div><hr><h4>isNotEmpty</h4><pre>visibility: public</pre><pre>type: Set a -> Boolean</pre><div><p>Returns true if this set is not empty.
Runtime: O(1)</p>
</div><hr><h4>nth</h4><pre>visibility: public</pre><pre>type: Int32 -> Set a -> Option a</pre><div><p>Returns some value at index for this set if it exists or none.
Runtime: ~O(1)</p>
</div><hr><h4>randNth</h4><pre>visibility: public</pre><pre>type: Set a -> Option a</pre><div><p>Returns a random element of this set if the set is not empty.
Runtime: O(1)</p>
</div><hr><h4>union</h4><pre>visibility: public</pre><pre>type: Set a -> Set a -> Set a</pre><div><p>Returns the union of these 2 sets.
This is the same as <code>set1 ++ set2</code>.</p>
</div><hr><h4>difference</h4><pre>visibility: public</pre><pre>type: Set a -> Set a -> Set a</pre><div><p>Returns all elements in set 1 that are not in set 2.</p>
</div><hr><h4>intersection</h4><pre>visibility: public</pre><pre>type: Set a -> Set a -> Set a</pre><div><p>Returns the intersection between these 2 sets.</p>
</div><hr><h4>stream</h4><pre>visibility: public</pre><pre>type: Set a -> Stream a</pre><div><p>Returns a stream for this set.</p>
</div><hr><h4>fromStream</h4><pre>visibility: public</pre><pre>type: Stream a -> Set a</pre><div><p>Collects this stream into a set.
Runtime: O(n)</p>
</div><hr><h4>forEach</h4><pre>visibility: public</pre><pre>type: Set a -> (a -> Unit) -> Unit</pre><div><p>Runs function f for every element of this set, ignoring the result.
Runtime: O(n)</p>
</div><hr><h4>forEachIndexed</h4><pre>visibility: public</pre><pre>type: Set a -> (Int32 -> a -> Unit) -> Unit</pre><div><p>Runs function f for every index and element of this set, ignoring the result.
Runtime: O(n)</p>
</div><hr><h4>map</h4><pre>visibility: public</pre><pre>type: (a -> b) -> Set a -> Set b</pre><div><p>Maps function f over all elements of this set
returning a set of the same size.
Runtime: O(n)</p>
</div><hr><h4>filter</h4><pre>visibility: public</pre><pre>type: (a -> Boolean) -> Set a -> Set a</pre><div><p>Returns an array of the elements that match the given predicate.
Runtime: O(n)</p>
</div><hr><h4>find</h4><pre>visibility: public</pre><pre>type: (a -> Boolean) -> Set a -> Option a</pre><div><p>Returns the first occurrence of elem in the set for which the predicate returns true.
This function uses the set's equality function, set at creation time.
Runtime: O(n)</p>
</div><hr><h4>foldl</h4><pre>visibility: public</pre><pre>type: (b -> a -> b) -> b -> Set a -> b</pre><div><p>Reduces this set to a single value according to the reducing function.
Goes from the left to the right.
Runtime: O(n)</p>
</div><hr><h4>reduce</h4><pre>visibility: public</pre><pre>type: (a -> a -> a) -> Set a -> Option a</pre><div><p>A specialized version of <code>foldl</code> where the first element of the set is used as initial value.
Returns none if the set is empty
Runtime: O(n)</p>
</div><hr><h4>flatten</h4><pre>visibility: public</pre><pre>type: Set (Set a) -> Set a</pre><div><p>Flattens a set of sets into a single set by concatenating them together.
Runtime: O(n)</p>
</div><hr><h4>flatMap</h4><pre>visibility: public</pre><pre>type: (a -> Set b) -> Set a -> Set b</pre><div><p>Like map, but the mapping function should return a set.
Flattens the result.
Runtime: O(n)</p>
</div><hr><h4>all</h4><pre>visibility: public</pre><pre>type: (a -> Boolean) -> Set a -> Boolean</pre><div><p>Returns true if the predicate is true for all elements in this set.
Runtime: O(n)</p>
</div><hr><h4>any</h4><pre>visibility: public</pre><pre>type: (a -> Boolean) -> Set a -> Boolean</pre><div><p>Returns true if the predicate is true for any element in this set.
Runtime: O(n)</p>
</div><hr><h4>count</h4><pre>visibility: public</pre><pre>type: (a -> Boolean) -> Set a -> Int32</pre><div><p>Returns the number of elements matching the given predicate.
Runtime: O(n)</p>
</div><hr><h4>min</h4><pre>visibility: public</pre><pre>type: {{ NumberOps a }} -> Set a -> Option a</pre><div><p>Returns the smallest number in the set, if the list is not empty.
Runtime: O(n)</p>
</div><hr><h4>minOr</h4><pre>visibility: public</pre><pre>type: {{ NumberOps a }} -> a -> Set a -> a</pre><div><p>Returns the smallest number in the set, or the default value.
Runtime: O(n)</p>
</div><hr><h4>minBy</h4><pre>visibility: public</pre><pre>type: {{ Ord b }} -> (a -> b) -> Set a -> Option a</pre><div><p>Returns the smallest element in the set according to the
given function, if the set is not empty.
Runtime: O(n)</p>
</div><hr><h4>minOf</h4><pre>visibility: public</pre><pre>type: {{ NumberOps b }} -> (a -> b) -> Set a -> Option b</pre><div><p>Returns the smallest element returned by applying the
function to every element in the set, if the set is not empty.
Runtime: O(n)</p>
</div><hr><h4>max</h4><pre>visibility: public</pre><pre>type: {{ NumberOps a }} -> Set a -> Option a</pre><div><p>Returns the biggest number in the set, if the list is not empty.
Runtime: O(n)</p>
</div><hr><h4>maxOr</h4><pre>visibility: public</pre><pre>type: {{ NumberOps a }} -> a -> Set a -> a</pre><div><p>Returns the biggest number in the set, or the default value.
Runtime: O(n)</p>
</div><hr><h4>maxBy</h4><pre>visibility: public</pre><pre>type: {{ Ord b }} -> (a -> b) -> Set a -> Option a</pre><div><p>Returns the biggest element in the set according to the
given function, if the set is not empty.
Runtime: O(n)</p>
</div><hr><h4>maxOf</h4><pre>visibility: public</pre><pre>type: {{ NumberOps b }} -> (a -> b) -> Set a -> Option b</pre><div><p>Returns the biggest element returned by applying the
function to every element in the set, if the set is not empty.
Runtime: O(n)</p>
</div><hr><h4>sum</h4><pre>visibility: public</pre><pre>type: {{ Plus a }} -> Set a -> a</pre><div><p>Returns the sum of all elements in this set.
Runtime: O(n)</p>
</div><hr><h4>sumOf</h4><pre>visibility: public</pre><pre>type: {{ Plus b }} -> (a -> b) -> Set a -> b</pre><div><p>Returns the sum of all elements by first applying the
function to every element in this set.
Runtime: O(n)</p>
</div><hr><h4>product</h4><pre>visibility: public</pre><pre>type: {{ Mult a }} -> Set a -> a</pre><div><p>Returns the product of all elements in this set.
Runtime: O(n)</p>
</div><hr><h4>productOf</h4><pre>visibility: public</pre><pre>type: {{ Mult b }} -> (a -> b) -> Set a -> b</pre><div><p>Returns the product of all elements by first applying the
function to every element in this set.
Runtime: O(n)</p>
</div><hr><h4>containsAll</h4><pre>visibility: public</pre><pre>type: List a -> Set a -> Boolean</pre><div><p>Returns true if every element in the list is contained in the set.
Runtime: O(n)</p>
</div><hr><h4>groupBy</h4><pre>visibility: public</pre><pre>type: (a -> b) -> Set a -> Map b (Set a)</pre><div><p>Groups the elements of the set according
to the the function.
Ex:</p>
<pre><code class="language-novah">groupBy isOdd #{1, 2, 3, 4, 5, 6}
// =&gt; { true: #{1, 3, 5}, false: #{2, 4, 6} }
</code></pre>
</div><hr><h4>fromList</h4><pre>visibility: public</pre><pre>type: List a -> Set a</pre><div><p>Returns a set with the same elements as the list,
with duplicates removed.
Runtime: O(n)</p>
</div><hr><h4>toList</h4><pre>visibility: public</pre><pre>type: Set a -> List a</pre><div><p>Returns a list of all elements in this set.
Runtime: O(n)</p>
</div><hr><h4>withLinear</h4><pre>visibility: public</pre><pre>type: Set a -> (Set a -> b) -> Set a</pre><div><p>Creates a linear (mutable) version of the given set and applies the function to it.
Returns a forked (persistent) version of the returned linear set.
This function should be used when lots of expensive mutating operations have to be run on a set
and can be seen as a builder for the resulting set.
All functions that alter sets like <code>add</code>, <code>remove</code>, etc.
will mutate a linear set.
Ex:
withLinear #{1, 2, 3} \set -&gt;
add 4 set
remove 1 set</p>
<p>-&gt; #{2, 3, 4}</p>
</div>
    </div>
</body>
</html>