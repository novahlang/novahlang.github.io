
h1 Module definition

p Every novah file should start with a module definition.

pre.code
  code.microlight.
    module my.namespace

    ...

h1 Imports

p.
  Imports need to be defined after the module definition and before any other definitions.
  They can be qualified with the `as` keyword or given a list of names to import.
  Type constructors can be imported explicitly for a type or all at once with `(..)`.
  Raw unqualified imports are not allowed except for core namespaces.

pre.code
  code.microlight.
    module my.namespace

    import module1 as Mod
    import module2 (fun1, Type1(Ctor1, Ctor2), Type2(..))

    // error
    import unqualified

h1 Entry point

p.
  Any namespace containing a public function called `main` with type `Array String -> Unit`
  will be compiled into a runnable jvm class.

pre.code
  code.microlight.
    module entrypoint

    pub
    main : Array String -> Unit
    main args =
      println ("Hello " ++ args.[0])

h1 Functions

p.
  Functions and values with their types can be easily defined.
  All values in Novah are immutable, so there are no global mutable variables.
  All top level definitions must start with a lower case character.

pre.code
  code.microlight.
    module functions

    // A comment
    fun1 : String -> Boolean
    fun1 str = str == "true"

    val1 : Int
    val1 = 9876543

    // Top level definitions require explicit types
    // unless they have a `noWarn` attribute
    // which can also be put at the module level
    \#[noWarn]
    times10 x = x * 10

h1 Algebraic data types (ADTs)

p.
  Types can be defined with the keyword `type`.
  A type can have multiple constructors (sum type) and multiple parameters (product type).
  Both types and constructors must start with an upper case character.

pre.code
  code.microlight.
    module types

    // Types can be parameterized
    type Option a = Some a | None

    // A public type with private constructors
    pub
    type Color = Red | Black

    // A public type with public constructors
    pub+
    type Point = Point Int Int

h1 Type aliases

p.
  An alias to a type can be created with the `typealias` keyword.
  Aliases are just syntatic sugar and are considered the same type as their alias by the compiler.
  `Int` is a typealias to `Int32`.

pre.code
  code.microlight.
    module types2

    typealias MyBoolean = Boolean

    // Type aliases can have parameters
    typealias Maybe a = Option a

    // Aliases cannot be recursive
    typealias Wrong a = Option (Wrong a)

h1 Strings

p Strings can be created with double quotes like in Java or with triple quotes for unescaped, multi-line strings.

pre.code
  code.microlight.
    \#[noWarn]
    module strings

    str1 = "hello world\n"

    str2 = """Triple quoted
    strings can span multiple lines
    and don't consider any kind of escape like \n \t
    """

h1 Conditional expressions

p Novah has two conditional expressions: `if` and `case`. 

pre.code
  code.microlight.
    module conditionals

    // Both the then and else cases must have the same type
    abs : Int -> Int
    abs x = if x > 0 then x else negate x

    // An if without an else must always return Unit
    printPositive : Int -> Unit
    printPositive x =
      if x > 0 then
        println x
    
    mapList : (a -> b) -> List a -> List b
    mapList f list = case list of
      [] -> []
      [x :: xs] -> [f x] ++ mapList f xs

p See 
  a(href="/pattern-matching") pattern matching.

h1 While loop

p Even though Novah support while loops, a tail recursive function is the idiomatic way to represent such constructs.

pre.code
  code.microlight.
    module loops

    // Not idiomatic
    factorialIterative : Int -> Int
    factorialIterative x =
      let fact = atom x
      let i = atom x

      while (deref i) > 1 do
        swap (_ - 1) i
        swap (_ * (deref i)) fact
      deref fact
    
    // Idiomatic version
    // Novah will optimize the tail recursion to a loop
    factorialRecursive : Int -> Int
    factorialRecursive x =
      let fact num acc = case num of
        0 -> acc
        1 -> acc
        n -> fact (n - 1) (acc * n)
      fact x 1

h1 Operators

p It's possible to define new operators in Novah.

pre.code
  code.microlight.
    module operators

    (?) : Option a -> a -> a
    (?) opt default = case opt of
      Some x -> x
      None -> default
    
    or0 : Option Int -> Int
    or0 n = n ? 0

h3 Associativity

table
  thead
    tr
      th Operator
      th Associativity
  tbody
    tr
      td <|
      td Right
    tr
      td $ starting operators
      td Right
    tr
      td : starting operators
      td Right
    tr
      td everything else
      td Left

h3 Precedence

table
  thead
    tr
      th Operator (first character)
      th Example
      th Precedence
  tbody
    tr
      td ;
      td (3 ; 5)
      td 0
    tr
      td $
      td -
      td 1
    tr
      td |
      td true || false
      td 2
    tr
      td &
      td true && false
      td 3
    tr
      td =, !
      td 3 == 1, list ! index
      td 4
    tr
      td >, <
      td 5 > 1, 3 <= 7
      td 5
    tr
      td +, -, :, ?
      td 1 + 1, head :: tail, option ? default
      td 6
    tr
      td *, /, %
      td 3 * 9, 5 / 2
      td 7
    tr
      td ^, .
      td [1 ... 10], 'a' .. 'z'
      td 8
    tr
      td ` (backtick operator)
      td (3 + 3) `shouldBe` 6
      td 9

h1 Ranges

p.
  Ranges are just normal user-defined operators in Novah.
  There is syntactic sugar for creating ranges of lists and sets.

pre.code
  code.microlight.
    \#[noWarn]
    module ranges

    zeroToTen = 1 .. 10
    
    digitList = [0 ... 10]

    charSet = \#{'a' .. 'z'}

    oddDigits = range 1 10 2

    pub
    main : Array String -> Unit
    main _ =
      forEachRange oddDigits println

h1 Collections

p Novah comes with literal support for commonly used data structures like lists, sets, maps, tuples and (row-polymorphic) records.

pre.code
  code.microlight.
    module collections

    aList : List Int
    aList = [1, 2, 3, 4, 5]

    aSet : Set Char
    aSet = \#{'a', 'b', 'c'}

    aTuple : Tuple Boolean Char
    aTuple = true ; 'z'

    aMap : Map String Int
    aMap = Map.new ["a" ; 0, "b" ; 1, "c" ; 2]

    pointRecord : { x : Float64, y : Float64 }
    pointRecord = {x: 1.2, y: 5.66}

h1 Type annotations and casts

p Novah requires almost no type annotations but values can still be annotated with a type

pre.code
  code.microlight.
    module annotations

    foo : Unit -> Int
    foo () =
      // annotate a value
      let pi = Math.pi : Float64
      // compilation error: types don't match
      let piInt = Math.pi : Int
      // annotate a parameter
      let fun (x : Int) = x + 1

p Top level values are required to be annotated for documentation purpose unless a \#[noWarn] attribute is present.

pre.code
  code.microlight.
    module annotations

    // compilation error: no type annotation
    foo () = 1

    // OK
    \#[noWarn]
    bar () = 1

p Types can also be cast to some other types with the `as` keyword. Casts should only be used for Java interoperability as they can cause runtime errors.

pre.code
  code.microlight.
    module casts

    toStringNullable : Nullable String -> String
    toStringNullable val =
      if val === null then
        "null"
      else
        val as String